import alpaca_trade_api as tradeapi
import time
import datetime
from datetime import datetime, timedelta 
from pytz import timezone
import pytz
import websocket, json
import threading

# Used for connecting to the Alpaca websocket
base_url="https://paper-api.alpaca.markets"
key_id="PK8SMHYDMZQKATKYHZR0"
secret_key="6jbn4qlYnYcZO8mFILlasMkHWolyTfvJhDWlrUKo"
api=tradeapi.REST(base_url=base_url,key_id=key_id,secret_key=secret_key)

# Time variables used to calculate the open time, close time, time to close, etc
nyc=timezone('America/New_York')
today=datetime.today().astimezone(nyc)
today_str=datetime.today().astimezone(nyc).strftime('%Y-%m-%d')
calendar=api.get_calendar(start=today_str, end=today_str)[0]
market_open=today.replace(
    hour=calendar.open.hour,
    minute=calendar.open.minute,
    second=0)
market_open=market_open.astimezone(nyc)
market_close=today.replace(
    hour=calendar.close.hour,
    minute=calendar.close.minute,
    second=0)
market_close=market_close.astimezone(nyc)
current_dt=datetime.today().astimezone(nyc)
since_market_open=current_dt-market_open

# Running variables holding security data
symbol_list=['AAPL','MSFT','GOOGL']
history15={}
averages={}
positions={}
last_trade_open={}
scale=100
start_message_time=datetime.now()
new_message=[]

def main():
    next_market_open=market_open
    print('Waiting for market to open...')
    while True:
        current_time=datetime.now()
        if since_market_open.seconds//60<390 and current_time.weekday()!=5 and current_time.weekday()!=6:
            print('Begin trading {}/{}/{}.'.format(current_time.month,current_time.day,current_time.year))
            print()
            #open_websocket()
            next_market_open=market_open+timedelta(days=1)
            print('Waiting for market to open...')
            print()
        time.sleep(60)
        update_time()

def open_websocket():
    global ws
    ws=websocket.WebSocketApp(
        "wss://stream.data.alpaca.markets/v2/iex", 
        on_open=on_open,
        on_message=on_message
    )
    ws.run_forever()
    return

def on_open(ws):
    auth_data={"action": "auth", "key": key_id, "secret": secret_key}
    listen_to_channels={"action":"subscribe","bars":symbol_list}
    ws.send(json.dumps(auth_data))
    ws.send(json.dumps(listen_to_channels))

def on_message(ws, message):
    global start_message_time
    global first_call
    global new_message
    #print(message)
    if since_market_open.seconds//60>=385:
        print('Ending trading, {}/{}/{}.'.format(today.month, today.day, today.year))
        print()
        ws.close()
        return

    tp=message[0:15]
    for i in range(12):
        if (tp[i]=='T' and 
        tp[i+1]=='"' and 
        tp[i+2]==':' and 
        tp[i+3]=='"' and
        tp[i+4]=='d'):
            new_message.append(message)
            thread=threading.Thread(target=get_close_price)
            thread.start()

def get_close_price():
    global new_message
    ticker={'s':'','c':''}
    item=''
    append=False
    first=True
    i=0
    message=new_message.pop(0)
    for char in message:
        if append and (char.isnumeric() or char.isalpha() or char=='.'):
            item+=char
            if message[i+1]=='"' or message[i+1]==',':
                if first:
                    ticker['s']=item
                    first=False
                    item=''
                else:
                    ticker['c']=float(item)
                append=False

        if (char=='S' or char=='c') and message[i+1]=='"':
            append=True
        i+=1
    sort15(ticker)
    if len(hisotry15)==15:
        handle_ticker_bar(ticker)
    
def sort15(ticker):
    global history15
    global averages
    avg_len=15
    if history15.get(ticker['s'],0)==0:
        history15[ticker['s']]=[float(ticker['c'])]

    elif len(history15[ticker['s']])!=avg_len:
        history15[ticker['s']].append(float(ticker['c']))

    elif len(history15[ticker['s']])==avg_len:
        history15[ticker['s']].pop(0)
        history15[ticker['s']].append(float(ticker['c']))
        averages[ticker['s']]=sum(history15[ticker['s']])/avg_len

def volatility(symbol):
    avg=sum(history15[symbol])/len(history15[symbol])
    diff_sum_square = 0 # Calculate the sum of differences between average and data points
    for value in history15[symbol]:
        diff_sum_square+=(value-avg)**2
    return (1/len(history15[symbol])*diff_sum_square)**0.5

def handle_minute_bar(ticker):
    global positions
    if len(history15[ticker['s']])>14:
        symbol=ticker['s']
        difference=averages[symbol]-ticker['c']
        
        if last_trade_open[symbol][0]:
            api.cancel_order(last_trade_open[symbol][1])
        
        account=api.get_account()
        buying_power=float(account.buying_power)
        equity=float(account.equity)
        multiplier=float(account.multiplier)
        position_quantity=0
        position_value=0
        
        try:
            position=api.get_position(symbol)
            position_quantity=float(position.qty)
            position_value=float(position.current_price)
        except Exception as e:
            # No positions exist
            i=e
        if difference<0 and position_quantity>0:
            submit_order(symbol,position_quantity,'sell','market','day')
            position[symbol]-=position_quantity
        elif difference>0 and position_quantity<=0 and volatility(symbol)<1 and buying_power>10:
            portfolio_share=difference/ticker['c']*scale
            target_position_value=equity*multiplier*portfolio_share
            amount_to_long=target_position_value-position_value
            
            if amount_to_long>buying_power:
                amount_to_long=buying_power
            
            quantity=amount_to_long/ticker['c']
            submit_order(symbol,quantity,'buy','market','day')

def submit_order(symbol,qty,side,market_type,time_in_force):
    global last_trade_open
    if qty==0:
        return
    try:
        order=api.submit_order(
            symbol=str(symbol),
            qty=str(qty),
            side=str(side),
            type=str(market_type),
            time_in_force=str(time_in_force)
        )
        if side=='sell':
            print('Removing {} {} to positions.'.format(qty,symbol))
        elif side=='buy':
            print('Adding {} {} to positions.'.format(qty,symbol))
        if order.status!='accepted':
            last_trade_open[symbol]=[True,order.id]
        else: last_trade_open[symbol]=[False,order.id]
    except Exception as e:
        print('Warning: '+str(e))

def liquidate():
    global positions
    for symbol in positions:
        submit_order(
            symbol=symbol,
            qty=positions[symbol],
            side='sell',
            market_type='market',
            time_in_force='day'
        )
        position.pop(symbol)

def update_time():
    
    global today
    global today_str
    global calendar
    global market_open
    global market_close
    global current_dt
    global since_market_open

    today = datetime.today().astimezone(nyc)
    today_str = datetime.today().astimezone(nyc).strftime('%Y-%m-%d')
    calendar = api.get_calendar(start=today_str, end=today_str)[0]
    market_open = today.replace(
        hour = calendar.open.hour,
        minute = calendar.open.minute,
        second = 0
    )
    market_open = market_open.astimezone(nyc)
    market_close = today.replace(
        hour = calendar.close.hour,
        minute = calendar.close.minute,
        second = 0
    )
    market_close = market_close.astimezone(nyc)
    current_dt = datetime.today().astimezone(nyc)
    since_market_open = current_dt - market_open

if __name__ == "__main__" and False:
    main()
